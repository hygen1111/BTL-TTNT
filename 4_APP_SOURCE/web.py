# -*- coding: utf-8 -*-
"""web.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WT_K5MqIgFUuuV8Zn60KLMVsu7wSsPHP
"""

# K·∫øt n·ªëi Google Drive
from google.colab import drive
import os

if not os.path.exists('/content/gdrive'):
    drive.mount('/content/gdrive')
else:
    print(" ƒê√£ k·∫øt n·ªëi Google Drive!")

# C√†i ƒë·∫∑t th∆∞ vi·ªán
!pip install -q streamlit ultralytics pyngrok

# T·∫°o file app.py b·∫±ng Python
app_code = '''import streamlit as st
import cv2
import torch
import torch.nn as nn
import numpy as np
from PIL import Image
from ultralytics import YOLO
import traceback

# --- C·∫§U H√åNH ---
DEVICE = torch.device('cpu')
torch.set_num_threads(4)
CHARS = "0123456789ABCDEFGHKLMNPRSTUVXYZ"
MODEL_PATH = "/content/gdrive/MyDrive/BTL-TTNT/3_MODELS_WEIGHTS/best.pt"
SAVE_PATH = "/content/gdrive/MyDrive/BTL-TTNT/3_MODELS_WEIGHTS/crnn_pro_final.pth"
PADDING = 10

PROVINCE_MAP = {
    "11": "Cao B·∫±ng", "12": "L·∫°ng S∆°n", "14": "Qu·∫£ng Ninh",
    "15": "H·∫£i Ph√≤ng", "16": "H·∫£i Ph√≤ng",
    "17": "Th√°i B√¨nh", "18": "Nam ƒê·ªãnh", "19": "Ph√∫ Th·ªç",
    "20": "Th√°i Nguy√™n", "21": "Y√™n B√°i", "22": "Tuy√™n Quang",
    "23": "H√† Giang", "24": "L√†o Cai", "25": "Lai Ch√¢u",
    "26": "S∆°n La", "27": "ƒêi·ªán Bi√™n", "28": "H√≤a B√¨nh",
    "29": "H√† N·ªôi", "30": "H√† N·ªôi", "31": "H√† N·ªôi",
    "32": "H√† N·ªôi", "33": "H√† N·ªôi", "34": "H·∫£i D∆∞∆°ng",
    "35": "Ninh B√¨nh", "36": "Thanh H√≥a", "37": "Ngh·ªá An",
    "38": "H√† Tƒ©nh", "43": "ƒê√† N·∫µng",
    "47": "ƒê·∫Øk L·∫Øk", "49": "L√¢m ƒê·ªìng",
    "50": "TP.HCM", "51": "TP.HCM", "52": "TP.HCM",
    "53": "TP.HCM", "54": "TP.HCM", "55": "TP.HCM",
    "56": "TP.HCM", "57": "TP.HCM", "58": "TP.HCM",
    "59": "TP.HCM",
    "60": "ƒê·ªìng Nai", "61": "B√¨nh D∆∞∆°ng", "62": "Long An",
    "63": "Ti·ªÅn Giang", "64": "Vƒ©nh Long", "65": "C·∫ßn Th∆°",
    "66": "ƒê·ªìng Th√°p", "67": "An Giang", "68": "Ki√™n Giang",
    "69": "C√† Mau", "70": "T√¢y Ninh", "71": "B·∫øn Tre",
    "72": "B√† R·ªãa - V≈©ng T√†u", "73": "Qu·∫£ng B√¨nh",
    "74": "Qu·∫£ng Tr·ªã", "75": "Th·ª´a Thi√™n Hu·∫ø", "76": "Qu·∫£ng Ng√£i",
    "77": "B√¨nh ƒê·ªãnh", "78": "Ph√∫ Y√™n", "79": "Kh√°nh H√≤a",
    "80": "C·ª•c CSGT", "81": "Gia Lai", "82": "Kon Tum",
    "83": "S√≥c TrƒÉng", "84": "Tr√† Vinh", "85": "Ninh Thu·∫≠n",
    "86": "B√¨nh Thu·∫≠n", "88": "Vƒ©nh Ph√∫c", "89": "H∆∞ng Y√™n",
    "90": "H√† Nam", "92": "Qu·∫£ng Nam", "93": "B√¨nh Ph∆∞·ªõc",
    "94": "B·∫°c Li√™u", "95": "H·∫≠u Giang", "97": "B·∫Øc K·∫°n",
    "98": "B·∫Øc Giang", "99": "B·∫Øc Ninh"
}

# --- KI·∫æN TR√öC CRNN ---
class CRNN(nn.Module):
    def __init__(self, nclass, nh=256):
        super(CRNN, self).__init__()
        self.cnn = nn.Sequential(
            nn.Conv2d(1, 64, 3, 1, 1), nn.BatchNorm2d(64), nn.ReLU(True), nn.MaxPool2d(2, 2),
            nn.Conv2d(64, 128, 3, 1, 1), nn.BatchNorm2d(128), nn.ReLU(True), nn.MaxPool2d(2, 2),
            nn.Conv2d(128, 256, 3, 1, 1), nn.BatchNorm2d(256), nn.ReLU(True),
            nn.Conv2d(256, 256, 3, 1, 1), nn.ReLU(True), nn.MaxPool2d((2, 1), (2, 1)),
            nn.Conv2d(256, 512, 3, 1, 1), nn.BatchNorm2d(512), nn.ReLU(True),
            nn.Conv2d(512, 512, 3, 1, 1), nn.ReLU(True), nn.MaxPool2d((2, 1), (2, 1)),
            nn.Conv2d(512, 512, 2, 1, 0), nn.BatchNorm2d(512), nn.ReLU(True)
        )
        self.rnn = nn.LSTM(512, nh, num_layers=2, bidirectional=True, batch_first=True)
        self.fc = nn.Linear(nh * 2, nclass)

    def forward(self, x):
        x = self.cnn(x)
        x = x.squeeze(2).permute(0, 2, 1)
        x, _ = self.rnn(x)
        return self.fc(x)

# --- TI·ªÄN X·ª¨ L√ù & DECODE ---
def preprocess_test(img):
    img = cv2.resize(img, (160, 32))
    if len(img.shape) == 3:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    img = cv2.equalizeHist(img)
    canny = cv2.Canny(img, 50, 150)
    img = cv2.addWeighted(img, 1.5, canny, 0.2, 0)
    return img / 255.0

def decode_predictions(preds, chars):
    preds = preds.argmax(2).transpose(1, 0).contiguous().numpy()
    decoded_texts = []
    for p in preds:
        tokens = [chars[idx-1] for i, idx in enumerate(p)
                  if idx > 0 and (i==0 or idx != p[i-1])]
        decoded_texts.append("".join(tokens))
    return decoded_texts

@st.cache_resource
def load_models():
    try:
        yolo = YOLO(MODEL_PATH)
        crnn = CRNN(nclass=len(CHARS) + 1).to(DEVICE)
        crnn.load_state_dict(torch.load(SAVE_PATH, map_location=DEVICE))
        crnn.eval()
        return yolo, crnn
    except Exception as e:
        st.error(f"‚ùå L·ªói khi load models: {str(e)}")
        return None, None

# --- GIAO DI·ªÜN STREAMLIT ---
st.set_page_config(page_title="Nh·∫≠n di·ªán bi·ªÉn s·ªë xe", page_icon="üöó", layout="wide")

st.title("üöó H·ªá th·ªëng nh·∫≠n di·ªán bi·ªÉn s·ªë xe Vi·ªát Nam")
st.markdown("---")

col1, col2 = st.columns([1, 1])

with col1:
    st.subheader("üì§ Upload ·∫£nh")
    uploaded_file = st.file_uploader(
        "Ch·ªçn ·∫£nh xe c·ªßa b·∫°n",
        type=["jpg", "png", "jpeg"],
        help="H·ªó tr·ª£ ƒë·ªãnh d·∫°ng: JPG, PNG, JPEG"
    )

if uploaded_file:
    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)
    img_bgr = cv2.imdecode(file_bytes, cv2.IMREAD_COLOR)
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

    with col1:
        st.image(img_rgb, caption="üì∑ ·∫¢nh g·ªëc", use_container_width=True)

    with col2:
        st.subheader("üéØ K·∫øt qu·∫£ nh·∫≠n di·ªán")

        if st.button("üöÄ B·∫Øt ƒë·∫ßu nh·∫≠n di·ªán", type="primary", use_container_width=True):
            try:
                with st.spinner("‚è≥ ƒêang t·∫£i models..."):
                    yolo_model, crnn_model = load_models()

                if yolo_model is None or crnn_model is None:
                    st.error("‚ùå Kh√¥ng th·ªÉ load models. Vui l√≤ng ki·ªÉm tra ƒë∆∞·ªùng d·∫´n!")
                    st.stop()

                with st.spinner("üîç ƒêang ph√°t hi·ªán bi·ªÉn s·ªë..."):
                    results = yolo_model(img_bgr, device='cpu', verbose=False)

                if not results[0].boxes or len(results[0].boxes) == 0:
                    st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y bi·ªÉn s·ªë trong ·∫£nh!")
                else:
                    st.success(f"‚úÖ T√¨m th·∫•y {len(results[0].boxes)} bi·ªÉn s·ªë!")
                    st.markdown("---")

                    for idx, box in enumerate(results[0].boxes):
                        with st.spinner(f"üìù ƒêang nh·∫≠n d·∫°ng bi·ªÉn s·ªë {idx+1}..."):
                            x1, y1, x2, y2 = map(int, box.xyxy[0])
                            h_o, w_o = img_bgr.shape[:2]
                            x1_p = max(0, x1 - PADDING)
                            y1_p = max(0, y1 - PADDING)
                            x2_p = min(w_o, x2 + PADDING)
                            y2_p = min(h_o, y2 + PADDING)

                            plate_crop = img_bgr[y1_p:y2_p, x1_p:x2_p]
                            processed = preprocess_test(plate_crop)
                            tensor = torch.tensor(processed).unsqueeze(0).unsqueeze(0).float().to(DEVICE)

                            with torch.no_grad():
                                preds = crnn_model(tensor)
                                preds_for_decode = preds.permute(1, 0, 2).log_softmax(2)
                                res_text = decode_predictions(preds_for_decode, CHARS)[0]

                            st.markdown(f"### üèçÔ∏è Bi·ªÉn s·ªë #{idx+1}")
                            c1, c2 = st.columns([1, 1])

                            with c1:
                                plate_rgb = cv2.cvtColor(plate_crop, cv2.COLOR_BGR2RGB)
                                st.image(plate_rgb, caption=f"·∫¢nh bi·ªÉn s·ªë {idx+1}", use_container_width=True)

                            with c2:
                                st.metric("Bi·ªÉn s·ªë nh·∫≠n di·ªán", res_text)
                                province_code = res_text[:2] if len(res_text) >= 2 else ""
                                province_name = PROVINCE_MAP.get(province_code, "Kh√¥ng x√°c ƒë·ªãnh")
                                st.info(f"üìç **T·ªânh/Th√†nh ph·ªë:** {province_name}")

                                if hasattr(box, 'conf'):
                                    conf = float(box.conf[0])
                                    st.progress(conf, text=f"ƒê·ªô tin c·∫≠y: {conf:.1%}")

                            if idx < len(results[0].boxes) - 1:
                                st.markdown("---")

            except Exception as e:
                st.error(f" ƒê√£ x·∫£y ra l·ªói: {str(e)}")
                with st.expander("üîç Chi ti·∫øt l·ªói"):
                    st.code(traceback.format_exc())

with st.sidebar:
    st.header("‚ÑπÔ∏è Th√¥ng tin h·ªá th·ªëng")
    st.markdown("""
    **C√¥ng ngh·ªá s·ª≠ d·ª•ng:**
    - üéØ YOLO: Ph√°t hi·ªán v·ªã tr√≠ bi·ªÉn s·ªë
    - üî§ CRNN: Nh·∫≠n d·∫°ng k√Ω t·ª±
    - üñºÔ∏è OpenCV: X·ª≠ l√Ω ·∫£nh

    **H∆∞·ªõng d·∫´n:**
    1. Upload ·∫£nh xe c√≥ bi·ªÉn s·ªë r√µ r√†ng
    2. Nh·∫•n "B·∫Øt ƒë·∫ßu nh·∫≠n di·ªán"
    3. Xem k·∫øt qu·∫£

    **L∆∞u √Ω:**
    - ·∫¢nh n√™n c√≥ ƒë·ªô ph√¢n gi·∫£i t·ªët
    - Bi·ªÉn s·ªë kh√¥ng b·ªã che khu·∫•t
    - √Ånh s√°ng ƒë·ªß ƒë·ªÉ nh√¨n r√µ
    """)
'''

# Ghi v√†o file
with open('app.py', 'w', encoding='utf-8') as f:
    f.write(app_code)

print("‚úÖ File app.py ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!")
print("üìÅ ƒê∆∞·ªùng d·∫´n:", os.path.abspath('app.py'))

from pyngrok import ngrok
import subprocess
import time
import getpass

# L·∫•y authtoken
print("=" * 70)
print("üîë L·∫§Y AUTHTOKEN T·∫†I: https://dashboard.ngrok.com/get-started/your-authtoken")
print("=" * 70)
authtoken = getpass.getpass("Nh·∫≠p ngrok authtoken c·ªßa b·∫°n: ")

# C·∫•u h√¨nh ngrok
ngrok.set_auth_token(authtoken)
ngrok.kill()  # Kill tunnel c≈© n·∫øu c√≥

# Kh·ªüi ƒë·ªông Streamlit
print("\nüöÄ ƒêang kh·ªüi ƒë·ªông Streamlit...")
proc = subprocess.Popen(
    ["streamlit", "run", "app.py", "--server.port", "8501", "--server.headless", "true"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE
)

# ƒê·ª£i Streamlit kh·ªüi ƒë·ªông
print("‚è≥ ƒêang ƒë·ª£i Streamlit s·∫µn s√†ng (15 gi√¢y)...")
time.sleep(15)

# T·∫°o ngrok tunnel
print("üåê ƒêang t·∫°o public URL...")
public_url = ngrok.connect(8501, bind_tls=True)

# Hi·ªÉn th·ªã k·∫øt qu·∫£
print("\n" + "=" * 70)
print("‚úÖ ·ª®NG D·ª§NG ƒê√É S·∫¥N S√ÄNG!")
print("=" * 70)
print(f"üåê URL: {public_url}")
print("=" * 70)
print("üí° M·ªü link tr√™n trong tr√¨nh duy·ªát ƒë·ªÉ s·ª≠ d·ª•ng ·ª©ng d·ª•ng")
print("‚ö†Ô∏è  Gi·ªØ cell n√†y ch·∫°y, ƒê·ª™NG d·ª´ng!")
print("üõë ƒê·ªÉ t·∫Øt ·ª©ng d·ª•ng: D·ª´ng runtime ho·∫∑c nh·∫•n n√∫t Stop ·ªü Colab")
print("=" * 70)

# Gi·ªØ cho ·ª©ng d·ª•ng ch·∫°y
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("\nüõë ƒêang t·∫Øt ·ª©ng d·ª•ng...")
    ngrok.kill()
    proc.terminate()
    print("‚úÖ ƒê√£ t·∫Øt!")