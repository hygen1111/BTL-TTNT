# -*- coding: utf-8 -*-
"""cắt_ảnh_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kmuc2k0poNqmB1HZZ_oSHiGL3l1I4CKo
"""

# ================== CÀI THƯ VIỆN ==================
!pip install -q ultralytics

# ================== IMPORT ==================
from ultralytics import YOLO
from google.colab import drive
import cv2
import os
import numpy as np

# ================== MOUNT DRIVE ==================
drive.mount('/content/drive')

# ================== CONFIG ==================
MODEL_PATH = '/content/drive/MyDrive/TTNT/3_MODELS_WEIGHTS/best.pt'
INPUT_FOLDER_PATH = '/content/drive/MyDrive/TTNT/Project_LPR_Video/Data_Training/valid/images'
OUTPUT_CROP_PATH = '/content/drive/MyDrive/TTNT/tap_valid'

CONF_THRES = 0.3

os.makedirs(OUTPUT_CROP_PATH, exist_ok=True)

# ================== DESKEW BẰNG HOUGH ==================
def deskew_plate(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5, 5), 0)

    edges = cv2.Canny(gray, 80, 200)

    lines = cv2.HoughLinesP(
        edges,
        rho=1,
        theta=np.pi / 180,
        threshold=80,
        minLineLength=img.shape[1] * 0.5,
        maxLineGap=10
    )

    if lines is None:
        return img

    angles = []
    for l in lines:
        x1, y1, x2, y2 = l[0]
        angle = np.degrees(np.arctan2(y2 - y1, x2 - x1))
        if abs(angle) < 10:
            angles.append(angle)

    if len(angles) < 2:
        return img

    angle = np.median(angles)

    h, w = img.shape[:2]
    M = cv2.getRotationMatrix2D((w // 2, h // 2), angle, 1.0)

    return cv2.warpAffine(
        img, M, (w, h),
        flags=cv2.INTER_CUBIC,
        borderMode=cv2.BORDER_REPLICATE
    )

# ================== TIGHT CROP THEO CHỮ ==================
def tight_crop(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    bw = cv2.adaptiveThreshold(
        gray, 255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        31, 5
    )

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    bw = cv2.morphologyEx(bw, cv2.MORPH_CLOSE, kernel, iterations=2)

    cnts, _ = cv2.findContours(bw, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return img

    c = max(cnts, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(c)

    pad = 4
    return img[
        max(0, y - pad): y + h + pad,
        max(0, x - pad): x + w + pad
    ]

# ================== ENHANCE NHẸ ==================
def enhance_image(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    gray = cv2.bilateralFilter(gray, 5, 40, 40)

    sharp = cv2.addWeighted(
        gray, 1.3,
        cv2.GaussianBlur(gray, (3, 3), 0),
        -0.3, 0
    )

    return cv2.cvtColor(sharp, cv2.COLOR_GRAY2BGR)

# ================== MAIN PIPELINE ==================
def run_yolo_crop_pipeline(model_path, input_folder, output_folder):
    print("Loading YOLO model...")
    model = YOLO(model_path)

    image_files = [
        f for f in os.listdir(input_folder)
        if f.lower().endswith(('.jpg', '.png', '.jpeg'))
    ]

    print(f"Số ảnh đầu vào: {len(image_files)}")

    total_crops = 0

    for img_name in image_files:
        img_path = os.path.join(input_folder, img_name)
        img = cv2.imread(img_path)

        if img is None:
            print("Không đọc được:", img_name)
            continue

        h_img, w_img = img.shape[:2]

        results = model.predict(img, conf=CONF_THRES, iou=0.7, verbose=False)

        for i, box in enumerate(results[0].boxes):
            x1, y1, x2, y2 = map(int, box.xyxy[0])

            # Chặn biên
            x1 = max(0, x1)
            y1 = max(0, y1)
            x2 = min(w_img, x2)
            y2 = min(h_img, y2)

            bw = x2 - x1
            bh = y2 - y1

            # ===== PADDING THEO % =====
            pad_x = int(bw * 0.12)
            pad_y = int(bh * 0.18)

            x1p = max(0, x1 - pad_x)
            y1p = max(0, y1 - pad_y)
            x2p = min(w_img, x2 + pad_x)
            y2p = min(h_img, y2 + pad_y)

            crop = img[y1p:y2p, x1p:x2p]

            if crop.size == 0:
                continue

            # ===== DESKEW =====
            if min(crop.shape[:2]) > 60:
                crop = deskew_plate(crop)

            # ===== TIGHT + ENHANCE =====
            crop = tight_crop(crop)
            crop = enhance_image(crop)

            # ===== SAVE =====
            crop_name = f"{os.path.splitext(img_name)[0]}_plate_{i}.jpg"
            crop_path = os.path.join(output_folder, crop_name)
            cv2.imwrite(crop_path, crop)

            total_crops += 1

    print("-" * 50)
    print(f"Tổng biển số đã cắt: {total_crops}")
    print(f"Lưu tại: {output_folder}")
    print("-" * 50)

# ================== RUN ==================
if __name__ == "__main__":
    run_yolo_crop_pipeline(
        MODEL_PATH,
        INPUT_FOLDER_PATH,
        OUTPUT_CROP_PATH
    )

import shutil
from google.colab import files
import os

OUTPUT_FOLDER = '/content/drive/MyDrive/TTNT/tap_valid'
ZIP_FILENAME = 'tap_valid.zip'

print(f"Đang nén thư mục: {OUTPUT_FOLDER}")

try:
    shutil.make_archive(
        base_name=ZIP_FILENAME.replace('.zip', ''),
        format='zip',
        root_dir=os.path.dirname(OUTPUT_FOLDER),
        base_dir=os.path.basename(OUTPUT_FOLDER)
    )

    print(f"Đã tạo file zip: {ZIP_FILENAME}")
    files.download(ZIP_FILENAME)

except Exception as e:
    print(f"Lỗi: {e}")